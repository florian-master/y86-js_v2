import {Sim} from "./sim"
import {registers_enum} from "./registers"
import {Memory} from "./memory"
import {simStatus} from "../status";


function is_halt(sim : Sim, icode : number){
    return icode == sim.getHaltIcode();
}

function fetch(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    sim.context.pc = sim.context.newPC;
    sim.context.valP = sim.context.pc;
    try {
        let byte = sim.memory.readByte(sim.context.valP);
        sim.context.valP++;

        sim.context.icode = Memory.HI4(byte);
        sim.context.ifun = Memory.LO4(byte);
    }
    catch (e) {
        sim.errorMessage = e;
        sim.status = simStatus.ADDR;
        return;
    }

    if(!sim.hcl.call( "instr_valid")) {
        sim.status = simStatus.INSTR;
        sim.errorMessage = "Invalid Instruction encountered";
        return;
    }

    if (is_halt(sim, sim.context.icode)){
        sim.status = simStatus.HALT;
        return;
    }

    if(sim.hcl.call("need_regids")) {
        try {
            let byte = sim.memory.readByte(sim.context.valP);
            byte = sim.memory.readByte(sim.context.valP);
            sim.context.valP++;

            sim.context.ra = Memory.HI4(byte);
            sim.context.rb = Memory.LO4(byte);
        }
        catch (e) {
            sim.errorMessage = e;
            sim.status = simStatus.ADDR;
            return;
        }
    } else {
        sim.context.ra = registers_enum.none;
        sim.context.rb = registers_enum.none
    }

    if(sim.hcl.call("need_valC")) {
        try {
            sim.context.valC = sim.memory.readWord(sim.context.valP);
            sim.context.valP += Memory.WORD_SIZE;
        }
        catch (e) {
            sim.errorMessage = e;
            sim.status = simStatus.ADDR;
            return;
        }
    } else {
        sim.context.valC = 0
    }

}

/**
 * Decode stage. Update srcA, srcB, dstE and dstM values, depending of function generated by sim.hcl.
 * @param sim
 */
function decode(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    sim.context.srcA = sim.hcl.call("srcA");
    if (sim.context.srcA != registers_enum.none) {
        sim.context.valA = sim.registers.read(sim.context.srcA);
    }
    else {
        sim.context.valA = 0;
    }

    sim.context.srcB = sim.hcl.call("srcB");
    if (sim.context.srcB != registers_enum.none) {
        sim.context.valB = sim.registers.read(sim.context.srcB);
    }
    else {
        sim.context.valB = 0;
    }

    sim.context.dstE = sim.hcl.call("dstE");
    sim.context.dstM = sim.hcl.call("dstM");
}

/**
 * Execute stage. Call alu_compute function.
 * @param sim
 */
function execute(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    sim.context.aluA = sim.hcl.call("aluA");
    sim.context.aluB = sim.hcl.call("aluB");
    let alu_fun = sim.hcl.call("alufun");

    // compute in valE from aluA and aluB
    try {
        sim.context.valE = sim.alu.compute_alu(sim.context.aluA, sim.context.aluB, alu_fun);
    }
    catch (e) {
        sim.status = simStatus.HALT;
        sim.errorMessage = e;
    }

    // Set flags
    if (sim.hcl.call("set_cc")) {
        sim.alu.compute_cc(sim.context.aluA, sim.context.aluB, alu_fun);
    }

    // bcond flag
    if (sim.hcl.call("is_bch")){
        sim.context.bcond = sim.alu.compute_bch(sim.context.ifun);
    }
    else {
        sim.context.bcond = false;
    }
}

/**
 * Memory stage. Decide whenever it need to write or read in memory. Both can't be done in one cycle in this
 * implementation of the y86.
 * @param sim
 */
function memory(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    let mem_addr = sim.hcl.call("mem_addr");
    let mem_data = sim.hcl.call("mem_data");

    if (sim.hcl.call("mem_read")) {
        try {
            sim.context.valM = sim.memory.readWord(mem_addr);
        }
        catch (e) {
            sim.status = simStatus.ADDR;
            sim.errorMessage = e;
            return;
        }
    }

    else if (sim.hcl.call("mem_write")) {
        try {
            sim.memory.writeWord(mem_addr, mem_data);
        }
        catch (e) {
            sim.status = simStatus.ADDR;
            sim.errorMessage = e;
            return;
        }
    }
}

/**
 * Write back stage. Uses dstE to find the register where to write the value in valE. Same for dstM.
 * Only if the register stored in dstE and/or dstM is not the special register 'none'.
 *
 * dstM and dstE were previously assigned in decode stage.
 * @param sim
 */
function writeBack(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    if (sim.context.dstE != registers_enum.none) {
        let valE = sim.context.valE;
        sim.registers.write(sim.context.dstE, valE);
    }

    if (sim.context.dstM != registers_enum.none) {
        let valM = sim.context.valM;
        sim.registers.write(sim.context.dstM, valM);
    }
}

/**
 * Update newPC value. Le PC value will not be erased at this time. It the job of the
 * fetch stage to update the pc with new pc.
 * @param sim
 */
function updatePC(sim : Sim) {
    if (sim.status != simStatus.AOK) {
        return;
    }

    sim.context.newPC = sim.hcl.call("new_pc");
}

export { decode, fetch, execute, memory, writeBack, updatePC }